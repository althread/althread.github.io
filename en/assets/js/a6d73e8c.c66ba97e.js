"use strict";(self.webpackChunkalthread=self.webpackChunkalthread||[]).push([[574],{125:(e,n,s)=>{s.r(n),s.d(n,{InstructionType:()=>d,assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>r,metadata:()=>a,toc:()=>o});var i=s(6070),t=s(5710);const r={sidebar_position:2},c="Althread Virtual Machine",a={id:"guide/internal/vm",title:"Althread Virtual Machine",description:"Virtual Machine State",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/guide/internal/vm.md",sourceDirName:"guide/internal",slug:"/guide/internal/vm",permalink:"/en/docs/guide/internal/vm",draft:!1,unlisted:!1,editUrl:"https://github.com/althread/althread/tree/main/doc/docs/guide/internal/vm.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"guideSidebar",previous:{title:"Architecture",permalink:"/en/docs/guide/internal/architecture"}},l={},d=({children:e,color:n,code:s,args:r})=>{const c={div:"div",span:"span",...(0,t.R)()};return(0,i.jsxs)(c.div,{id:s,children:[(0,i.jsxs)(c.div,{style:{fontFamily:"var(--ifm-font-family-monospace)",fontSize:"var(--ifm-code-font-size)",color:"#008cdf"},children:[(0,i.jsx)(c.span,{style:{color:"#008cdf"},children:s})," ",(0,i.jsx)(c.span,{style:{color:"rgb(174, 0, 223)"},children:r})]}),(0,i.jsx)(c.div,{style:{borderRadius:"2px",padding:"0 15px"},children:e})]})},o=[{value:"Virtual Machine State",id:"virtual-machine-state",level:2},{value:"Instructions",id:"instructions",level:2},{value:"Instruction Types",id:"instruction-types",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"althread-virtual-machine",children:"Althread Virtual Machine"})}),"\n",(0,i.jsx)(n.h2,{id:"virtual-machine-state",children:"Virtual Machine State"}),"\n",(0,i.jsx)(n.p,{children:"The state of the virtual machine is represented by:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The values of global variables"}),"\n",(0,i.jsx)(n.li,{children:"The state of communication channels (messages in transit)"}),"\n",(0,i.jsx)(n.li,{children:"A structure for each process in execution. The state of an executing process includes its execution stack, i.e., the process's local variables, and the value of the instruction pointer, which is the index of the instruction currently being executed."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The execution stack of a process contains no debugging information; it only includes the values of local variables and intermediate expression results in the form of a ",(0,i.jsx)(n.code,{children:"Literal"})," array. Expressions using local variables refer to the index of the variable in the process's execution stack. The index of a local variable is determined during compilation, enabling fast access during execution."]}),"\n",(0,i.jsx)(n.p,{children:"To simplify, global variables are stored in a HashMap (dictionary), and their values are directly accessible by name."}),"\n",(0,i.jsx)(n.h2,{id:"instructions",children:"Instructions"}),"\n",(0,i.jsxs)(n.p,{children:["The virtual machine's instructions are represented by an enum ",(0,i.jsx)(n.code,{children:"InstructionType"}),". Each instruction contains fields with the information required for its execution:"]}),"\n","\n",(0,i.jsx)(n.h3,{id:"instruction-types",children:"Instruction Types"}),"\n",(0,i.jsx)("table",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#Empty",children:"Empty"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#Expression",children:"Expression"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#Push",children:"Push"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#Unstack",children:"Unstack"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#Destruct",children:"Destruct"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#GlobalReads",children:"GlobalReads"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#GlobalAssignment",children:"GlobalAssignment"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#LocalAssignment",children:"LocalAssignment"})}),"\n"]})}),(0,i.jsx)("td",{children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#Declaration",children:"Declaration"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#RunCall",children:"RunCall"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#FnCall",children:"FnCall"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#JumpIf",children:"JumpIf"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#Jump",children:"Jump"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#Break",children:"Break"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#ChannelPeek",children:"ChannelPeek"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#ChannelPop",children:"ChannelPop"})}),"\n"]})}),(0,i.jsx)("td",{children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#WaitStart",children:"WaitStart"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#Wait",children:"Wait"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#Send",children:"Send"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#Connect",children:"Connect"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#AtomicStart",children:"AtomicStart"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#AtomicEnd",children:"AtomicEnd"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#EndProgram",children:"EndProgram"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#Exit",children:"Exit"})}),"\n"]})})]})}),"\n",(0,i.jsx)(d,{code:"Empty",children:(0,i.jsx)(n.p,{children:"An empty instruction, does nothing."})}),"\n",(0,i.jsx)(d,{code:"Expression",args:"(LocalExpressionNode)",children:(0,i.jsxs)(n.p,{children:["Evaluates an expression and pushes the result onto the stack. ",(0,i.jsx)(n.code,{children:"LocalExpressionNode"})," is the root of a tree representing the expression."]})}),"\n",(0,i.jsx)(d,{code:"Push",args:"(Literal)",children:(0,i.jsx)(n.p,{children:"Pushes the given literal onto the stack."})}),"\n",(0,i.jsx)(d,{code:"Unstack",args:"{unstack_len: usize}",children:(0,i.jsxs)(n.p,{children:["Removes ",(0,i.jsx)(n.code,{children:"unstack_len"})," values from the stack."]})}),"\n",(0,i.jsx)(d,{code:"Destruct",args:"",children:(0,i.jsx)(n.p,{children:"Replaces the tuple at the top of the stack with its elements. A tuple with 3 elements will be replaced by 3 values on the stack."})}),"\n",(0,i.jsx)(d,{code:"GlobalReads",args:"{variables: Vec<String>, only_const: bool}",children:(0,i.jsxs)(n.p,{children:["Pushes the values of the global variables onto the stack. The ",(0,i.jsx)(n.code,{children:"only_const"})," field indicates whether all variables are constants (if so, the instruction can be optimized since it\u2019s not global)."]})}),"\n",(0,i.jsx)(d,{code:"GlobalAssignment",args:"{identifier: String, operator: BinaryAssignmentOperator, unstack_len: usize}",children:(0,i.jsxs)(n.p,{children:["Assigns the value at the top of the stack to the given global variable ",(0,i.jsx)(n.code,{children:"identifier"})," and removes ",(0,i.jsx)(n.code,{children:"unstack_len"})," values from the stack."]})}),"\n",(0,i.jsx)(d,{code:"LocalAssignment",args:"{index: usize, operator: BinaryAssignmentOperator, unstack_len: usize}",children:(0,i.jsxs)(n.p,{children:["Assigns the value at the top of the stack to the local variable at the given index ",(0,i.jsx)(n.code,{children:"index"})," and removes ",(0,i.jsx)(n.code,{children:"unstack_len"})," values from the stack."]})}),"\n",(0,i.jsx)(d,{code:"Declaration",args:"{unstack_len: usize}",children:(0,i.jsxs)(n.p,{children:["Declares a variable in the current scope, initialized with the value at the top of the stack, and removes ",(0,i.jsx)(n.code,{children:"unstack_len"})," values from the stack."]})}),"\n",(0,i.jsx)(d,{code:"RunCall",args:"{name: String, unstack_len: usize}",children:(0,i.jsxs)(n.p,{children:["Starts a new thread executing the program ",(0,i.jsx)(n.code,{children:"name"})," with the value at the top of the stack as an argument, then removes ",(0,i.jsx)(n.code,{children:"unstack_len"})," values from the stack. Finally, adds the thread's PID to the stack."]})}),"\n",(0,i.jsx)(d,{code:"FnCall",args:"{name: String, unstack_len: usize, variable_idx: Option<usize>, arguments: Option<Vec<usize>}>",children:(0,i.jsxs)(n.p,{children:["Calls the function ",(0,i.jsx)(n.code,{children:"name"})," with local arguments at the given indexes, then removes ",(0,i.jsx)(n.code,{children:"unstack_len"})," values from the stack. If ",(0,i.jsx)(n.code,{children:"variable_idx"})," is provided, the function is a method of the object at the given index. Finally, the function result is added to the stack, if it returns a value."]})}),"\n",(0,i.jsx)(d,{code:"JumpIf",args:"{jump_false: i64, unstack_len: usize}",children:(0,i.jsxs)(n.p,{children:["Jumps to instruction ",(0,i.jsx)(n.code,{children:"jump_false"})," if the value at the top of the stack is false, then removes ",(0,i.jsx)(n.code,{children:"unstack_len"})," values from the stack. The jump value is relative to the current instruction."]})}),"\n",(0,i.jsx)(d,{code:"Jump",args:"{jump: i64}",children:(0,i.jsxs)(n.p,{children:["Jumps to instruction ",(0,i.jsx)(n.code,{children:"jump"}),". The jump value is relative to the current instruction."]})}),"\n",(0,i.jsx)(d,{code:"Break",args:"{jump: i64, unstack_len: usize, stop_atomic: bool}",children:(0,i.jsxs)(n.p,{children:["Jumps to instruction ",(0,i.jsx)(n.code,{children:"jump"})," while removing ",(0,i.jsx)(n.code,{children:"unstack_len"})," values from the stack. If ",(0,i.jsx)(n.code,{children:"stop_atomic"})," is true, stops atomic execution."]})}),"\n",(0,i.jsx)(d,{code:"ChannelPeek",args:"{channel_name: String}",children:(0,i.jsxs)(n.p,{children:["Checks if a message is available in the channel ",(0,i.jsx)(n.code,{children:"channel_name"}),". If so, adds the message and ",(0,i.jsx)(n.code,{children:"true"})," to the stack; otherwise, adds ",(0,i.jsx)(n.code,{children:"false"}),"."]})}),"\n",(0,i.jsx)(d,{code:"ChannelPop",args:"{channel_name: String}",children:(0,i.jsxs)(n.p,{children:["Removes the message from the channel ",(0,i.jsx)(n.code,{children:"channel_name"})," (does not add it to the stack)."]})}),"\n",(0,i.jsx)(d,{code:"WaitStart",args:"{dependencies: WaitDependency, start_atomic: bool}",children:(0,i.jsxs)(n.p,{children:["Starts a wait on a condition using the given dependencies. If ",(0,i.jsx)(n.code,{children:"start_atomic"})," is true, begins an atomic section. Dependencies include global variables or channels used in the condition. This instruction does not modify the virtual machine state and merely indicates the start of a waiting zone."]})}),"\n",(0,i.jsx)(d,{code:"Wait",args:"{jump: i64, unstack_len: usize}",children:(0,i.jsxs)(n.p,{children:["If the top of the stack is ",(0,i.jsx)(n.code,{children:"false"}),", jumps to ",(0,i.jsx)(n.code,{children:"jump"})," (relative to the next instruction); otherwise, proceeds to the next instruction. In both cases, removes ",(0,i.jsx)(n.code,{children:"unstack_len"})," values from the stack."]})}),"\n",(0,i.jsx)(d,{code:"Send",args:"{channel_name: String, unstack_len: usize}",children:(0,i.jsxs)(n.p,{children:["Sends the value at the top of the stack to the channel ",(0,i.jsx)(n.code,{children:"channel_name"}),", then removes ",(0,i.jsx)(n.code,{children:"unstack_len"})," values from the stack."]})}),"\n",(0,i.jsx)(d,{code:"Connect",args:"{sender_pid: Option<usize>, receiver_pid: Option<usize>, sender_channel: String, receiver_channel: String}",children:(0,i.jsxs)(n.p,{children:["Connects ",(0,i.jsx)(n.code,{children:"sender_channel"})," and ",(0,i.jsx)(n.code,{children:"receiver_channel"})," between the processes ",(0,i.jsx)(n.code,{children:"sender_pid"})," and ",(0,i.jsx)(n.code,{children:"receiver_pid"}),". If ",(0,i.jsx)(n.code,{children:"sender_pid"})," or ",(0,i.jsx)(n.code,{children:"receiver_pid"})," is ",(0,i.jsx)(n.code,{children:"None"}),", the current process is used. If a ",(0,i.jsx)(n.code,{children:"Send"})," has already occurred, the message is directly transferred."]})}),"\n",(0,i.jsx)(d,{code:"AtomicStart",args:"",children:(0,i.jsxs)(n.p,{children:["Begins an atomic section where processes cannot be interrupted, preventing concurrency issues. An atomic section ends with ",(0,i.jsx)(n.code,{children:"AtomicEnd"})," and must not contain wait instructions, except at the beginning."]})}),"\n",(0,i.jsx)(d,{code:"AtomicEnd",args:"",children:(0,i.jsx)(n.p,{children:"Ends an atomic section."})}),"\n",(0,i.jsx)(d,{code:"EndProgram",args:"",children:(0,i.jsx)(n.p,{children:"Terminates the current process."})}),"\n",(0,i.jsx)(d,{code:"Exit",args:"",children:(0,i.jsx)(n.p,{children:"Terminates all processes."})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"InstructionType"})," enum is defined in the file ",(0,i.jsx)(n.a,{href:"https://github.com/althread/althread/blob/main/interpreter/src/vm/instruction.rs#L12",children:"/vm/src/instruction.rs"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},5710:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>a});var i=s(758);const t={},r=i.createContext(t);function c(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);