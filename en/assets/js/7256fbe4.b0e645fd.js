"use strict";(self.webpackChunkalthread=self.webpackChunkalthread||[]).push([[246],{7025:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var i=t(6070),s=t(5710);const o={sidebar_pos:1},a="Multiple Message Waiting",r={id:"guide/channels/multiple-wait",title:"Multiple Message Waiting",description:"It is possible to wait for messages from multiple channels simultaneously. To do this, simply use the wait instruction followed by the waiting type first or seq and use a block with different conditions (similar to a match in Rust).",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/guide/channels/multiple-wait.md",sourceDirName:"guide/channels",slug:"/guide/channels/multiple-wait",permalink:"/en/docs/guide/channels/multiple-wait",draft:!1,unlisted:!1,editUrl:"https://github.com/althread/althread/tree/main/doc/docs/guide/channels/multiple-wait.md",tags:[],version:"current",frontMatter:{sidebar_pos:1},sidebar:"guideSidebar",previous:{title:"Creating a Channel",permalink:"/en/docs/guide/channels/create"},next:{title:"Creating Tests",permalink:"/en/docs/guide/test"}},c={},l=[];function d(e){const n={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"multiple-message-waiting",children:"Multiple Message Waiting"})}),"\n",(0,i.jsxs)(n.p,{children:["It is possible to wait for messages from multiple channels simultaneously. To do this, simply use the ",(0,i.jsx)(n.code,{children:"wait"})," instruction followed by the waiting type ",(0,i.jsx)(n.code,{children:"first"})," or ",(0,i.jsx)(n.code,{children:"seq"})," and use a block with different conditions (similar to a ",(0,i.jsx)(n.code,{children:"match"})," in Rust)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-althread",children:'program A() {\n    wait first {\n        receive channel_name1(x) => {\n            print("message received, x=", x);\n        }\n        receive channel_name2(y) => {\n            print("message received, y=", y);\n        }\n        X == 5 => {\n            print("x is equal to 5");\n        }\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"wait first"})," means that only one block of code will be executed. If multiple conditions are verified simultaneously, only one will be considered, the corresponding block will be executed, and then the process will continue its execution after the ",(0,i.jsx)(n.code,{children:"wait"})," block.\n",(0,i.jsx)(n.code,{children:"wait seq"})," means that when a condition is verified, the corresponding block is executed, then the following conditions are evaluated in order, and each block corresponding to a verified condition is executed, after which the process will continue its execution after the ",(0,i.jsx)(n.code,{children:"wait"})," block."]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},5710:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(758);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);