"use strict";(self.webpackChunkalthread=self.webpackChunkalthread||[]).push([[343],{8005:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>c,toc:()=>d});var s=n(6070),i=n(5710);const r={sidebar_pos:1},a="Attente multiple de messages",c={id:"guide/channels/multiple-wait",title:"Attente multiple de messages",description:"Il est possible d'attendre des messages de plusieurs canaux simultan\xe9ment. Pour cela, il suffit d'utiliser l'instruction wait suivit du type d'attente first ou seq et d'utiliser un bloc avec les diff\xe9rentes conditions (\xe0 la mani\xe8re d'un match en Rust).",source:"@site/docs/guide/channels/multiple-wait.md",sourceDirName:"guide/channels",slug:"/guide/channels/multiple-wait",permalink:"/docs/guide/channels/multiple-wait",draft:!1,unlisted:!1,editUrl:"https://github.com/althread/althread/tree/main/doc/docs/guide/channels/multiple-wait.md",tags:[],version:"current",frontMatter:{sidebar_pos:1},sidebar:"guideSidebar",previous:{title:"Cr\xe9ation d'un canal",permalink:"/docs/guide/channels/create"},next:{title:"Cr\xe9er des tests",permalink:"/docs/guide/test"}},l={},d=[];function o(e){const t={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"attente-multiple-de-messages",children:"Attente multiple de messages"})}),"\n",(0,s.jsxs)(t.p,{children:["Il est possible d'attendre des messages de plusieurs canaux simultan\xe9ment. Pour cela, il suffit d'utiliser l'instruction ",(0,s.jsx)(t.code,{children:"wait"})," suivit du type d'attente ",(0,s.jsx)(t.code,{children:"first"})," ou ",(0,s.jsx)(t.code,{children:"seq"})," et d'utiliser un bloc avec les diff\xe9rentes conditions (\xe0 la mani\xe8re d'un ",(0,s.jsx)(t.code,{children:"match"})," en Rust)."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-althread",children:'program A() {\n    wait first {\n        receive channel_name1(x) => {\n            print("message re\xe7u, x=", x);\n        }\n        receive channel_name2(y) => {\n            print("message re\xe7u, y=", y);\n        }\n        X == 5 => {\n            print("x est \xe9gal \xe0 5");\n        }\n    }\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"wait first"})," signifie qu'un seul bloc de code sera ex\xe9cut\xe9. Si plusieurs conditions sont v\xe9rifi\xe9es simultan\xe9ment, une seule sera consid\xe9r\xe9e, le bloc correspondant sera ex\xe9cut\xe9, puis le processus continuera son ex\xe9cution apr\xe8s le bloc ",(0,s.jsx)(t.code,{children:"wait"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"wait seq"})," signifie que, lorsqu'une condition est v\xe9rifi\xe9e, le bloc correspondant est ex\xe9cut\xe9, puis les conditions suivantes sont \xe9valu\xe9es dans l'ordre et chaque bloc correspondant \xe0 une condition v\xe9rifi\xe9e est ex\xe9cut\xe9, puis le processus continuera son ex\xe9cution apr\xe8s le bloc ",(0,s.jsx)(t.code,{children:"wait"}),"."]})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},5710:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>c});var s=n(758);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);